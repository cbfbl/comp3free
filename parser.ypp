%{
	#include <iostream>
	#include <stdlib.h>
    #include <string>
    #include <vector>

    #include "types.hpp"
	#include "hw3_output.hpp"
    #include "handler.hpp"
	extern int yylex();
	extern int yylineno;
    Handler handler;
	int yyerror(const char * message);
%}

%token BOOL
%token VOID INT BYTE B TRUE FALSE RETURN WHILE IF
%token BREAK CONTINUE SC COMMA LPAREN RPAREN LBRACE RBRACE
%token  ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left RELEQ
%nonassoc RELOP
%left BINOPL
%left BINOPH
%right NOT
%nonassoc THEN
%nonassoc ELSE


%%

Program	: Funcs 														{handler.handleRule(1,vector<Basictype*>());};
Funcs : /*epsilon*/ 													{handler.handleRule(2,vector<Basictype*>());};
Funcs : FuncDecl Funcs 													{handler.handleRule(3,vector<Basictype*>());};
FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE 	{handler.handleRule(4,vector<Basictype*>());};
RetType : Type															{handler.handleRule(5,vector<Basictype*>());};
RetType : VOID 															{handler.handleRule(6,vector<Basictype*>());};
Formals : /*epsilon*/ 													{handler.handleRule(7,vector<Basictype*>());};
Formals : FormalsList 												    {handler.handleRule(8,vector<Basictype*>());};
FormalsList : FormalDecl 												{handler.handleRule(9,vector<Basictype*>());};
FormalsList : FormalDecl COMMA FormalsList 								{handler.handleRule(10,vector<Basictype*>());};
FormalDecl : Type ID 													{handler.handleRule(11,vector<Basictype*>());};
Statements : Statement 													{handler.handleRule(12,vector<Basictype*>());};
Statements : Statements Statement 										{handler.handleRule(13,vector<Basictype*>());};
Statement : LBRACE Statements RBRACE 									{handler.handleRule(14,vector<Basictype*>());};
Statement : Type ID SC 													{handler.handleRule(15,vector<Basictype*>());};
Statement : Type ID ASSIGN Exp SC										{handler.handleRule(16,vector<Basictype*>());};
Statement : ID ASSIGN Exp SC 											{handler.handleRule(17,vector<Basictype*>());};
Statement : Call SC 													{handler.handleRule(18,vector<Basictype*>());};
Statement : RETURN SC													{handler.handleRule(19,vector<Basictype*>());};
Statement : RETURN Exp SC												{handler.handleRule(20,vector<Basictype*>());};
Statement : IF LPAREN Exp RPAREN Statement %prec THEN					{handler.handleRule(21,vector<Basictype*>());};
Statement : IF LPAREN Exp RPAREN Statement ELSE Statement				{handler.handleRule(22,vector<Basictype*>());};
Statement : WHILE LPAREN Exp RPAREN Statement %prec THEN				{handler.handleRule(23,vector<Basictype*>());};
Statement : WHILE LPAREN Exp RPAREN Statement ELSE Statement			{handler.handleRule(24,vector<Basictype*>());};
Statement : BREAK SC 													{handler.handleRule(25,vector<Basictype*>());};
Statement : CONTINUE SC 												{handler.handleRule(26,vector<Basictype*>());};
Call : ID LPAREN ExpList RPAREN											{handler.handleRule(27,vector<Basictype*>());};
Call : ID LPAREN RPAREN													{handler.handleRule(28,vector<Basictype*>());};
ExpList : Exp															{handler.handleRule(29,vector<Basictype*>());};
ExpList : Exp COMMA ExpList												{handler.handleRule(30,vector<Basictype*>());};
Type : INT																{handler.handleRule(31,vector<Basictype*>());};
Type : BYTE																{handler.handleRule(32,vector<Basictype*>());};
Type : BOOL															    {handler.handleRule(33,vector<Basictype*>());};
Exp : LPAREN Exp RPAREN													{handler.handleRule(34,vector<Basictype*>());};
Exp : Exp BINOPH Exp 													{handler.handleRule(35,vector<Basictype*>());};
Exp : Exp BINOPL Exp													{handler.handleRule(36,vector<Basictype*>());};
Exp : ID																{handler.handleRule(37,vector<Basictype*>());};
Exp : Call																{handler.handleRule(38,vector<Basictype*>());};
Exp : NUM																{handler.handleRule(39,vector<Basictype*>());};
Exp : NUM B																{handler.handleRule(40,vector<Basictype*>());};
Exp : STRING															{handler.handleRule(41,vector<Basictype*>());};
Exp : TRUE																{handler.handleRule(42,vector<Basictype*>());};
Exp : FALSE															    {handler.handleRule(43,vector<Basictype*>());};
Exp : NOT Exp															{handler.handleRule(44,vector<Basictype*>());};
Exp : Exp AND Exp													    {handler.handleRule(45,vector<Basictype*>());};
Exp : Exp OR Exp 														{handler.handleRule(46,vector<Basictype*>());};
Exp : Exp RELOP Exp														{handler.handleRule(47,vector<Basictype*>());};
Exp : Exp RELEQ Exp														{handler.handleRule(48,vector<Basictype*>());};

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}